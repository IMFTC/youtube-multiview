<!DOCTYPE HTML>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>YouTube Multiview</title>
    <link href="css/style.css" rel="stylesheet">
  </head>

  <body>
    <div id="main-container">
    </div>
    <div id="settings">
      <div>
        <label for="url-input">Add Video ID:</label>
        <input type="text"
               id="url-input">
        <button type="button"
                id="url-button">
          Load
        </button>
      </div>

      <div>
        <label for="size-input">Number of videos on screen:</label>
        <select id="size-select">
          <option value="1x1">1x1</option>
          <option value="2x2">2x2</option>
          <option value="3x3">3x3</option>
          <option value="4x4">4x4</option>
          <option value="fitall">Fit all</option>
        </select>
      </div>
      <div>
        <button id="edit-button">Edit</button>
      </div>
    </div>
    <div id="footer">
      <b>YouTube Multiview</b><br> The source code for this page is hosted on <a href="https://github.com/IMFTC/yt-multiview">GitHub</a>
    </div>
  </body>

  <script>
    // We keep the script inside the html page and not in a separte
// file so this page can easily be downloaded and used locally. If
// the script is in a separate file browsers will block access to
// it as Cross-Origin Requests.

const html = document.getElementsByTagName("html")[0];
const body = document.getElementsByTagName("body")[0];

// elements containing the iframes
const mainContainer = document.getElementById("main-container");
const videoStacks = document.getElementsByClassName("video-stack")

// input elements
const urlInput = document.getElementById("url-input");
const urlButton = document.getElementById("url-button");
const sizeSelect = document.getElementById("size-select");
const editButton = document.getElementById("edit-button");
let videoSelector = null;

// maps n = 0, 1, ... to the n-th videoStack
const videoStackOrder = {};

let nVideosOnScreen = 1;
let debug = true;

function extractYouTubeID(url){
    url = url.split(/(vi\/|v=|\/v\/|youtu\.be\/|\/embed\/)/);
    return url.length > 1 ? url[2].split(/[^0-9a-z_\-]/i)[0] : url[0];
}

//  Takes a string with youtube URLs or video IDs separated by comma or
//  whitespace and returns an array containing only the video IDs.
function extractVideoIDs(string) {
    let videoIDs = [];
    // replace any whitespace sequence to one ','
    let ids = string.replace(/\s+/, ',').split(',');
    return ids.map(extractYouTubeID)
}

function processURL() {
    let params = new URLSearchParams(document.location.search.substring(1));
    // v is a comma separated list of YouTube video IDs
    debug = (params.has("debug"));
    console.debug("Debugging mode is " + (debug ? "on" : "off"));
    let v = params.get("v");
    let videoIDs = extractVideoIDs(v);

    console.debug("Loading videoStacks for videoIDs: " + videoIDs);

    videoIDs.forEach(id => {
        appendVideoStackForYoutubeID(id);
    })
}

function appendVideoStackForYoutubeID(id) {
    let videoStack = createVideoStack(id);
    videoStack.style.order = videoStacks.length;
    videoStackOrder[videoStacks.length] = videoStack;
    mainContainer.appendChild(videoStack);
    console.debug("Added videoStack for video ID " + id);

    // "fitall" may require a new layout
    if (sizeSelect.value == "fitall") {
        updateGridColAndRows();
    }

    // TODO: Use a proper state object
    let edit = editButton.innerHTML != "Edit";
    videoStack.children[1].style.visibility = edit ? "visible" : "hidden";
}

function createVideoStack(id) {
    let videoStack = document.createElement("div");
    videoStack.className = "video-stack";

    let iframe = createIframeForYouTubeID(id);
    let overlay = createOverlayForYouTubeID(id);
    videoStack.appendChild(iframe);
    videoStack.appendChild(overlay);

    overlay.onmousemove = (mousemove) => {
        if (videoSelector.parentNode !== overlay) {
            moveVideoSelector(videoStack);
        }
    }

    return videoStack;
}

function createIframeForYouTubeID(id) {
    let iframe = document.createElement("iframe");
    iframe.id = id;

    if (debug) {
        iframe.style.background = "skyblue";
        iframe.srcdoc = "<div style='display: flex;\
            justify-content: center; align-items: stretch;\
            flex-direction: row; border-style: solid; border-radius: 5px; border-width: 2px;\
            border-XScolor: black;'><h1>" + id + "</h1></div>";
    } else {
        iframe.src="https://www.youtube.com/embed/" + id;
    }

    iframe.frameborder = "0";
    iframe.allow="accelerometer; autoplay; encrypted-media; "
        + "gyroscope; picture-in-picture; fullscreen";

    // this works for firefox, not tested with other browsers
    iframe.allowFullscreen = true;

    return iframe;
}

function createOverlayForYouTubeID(id) {
    let overlay = document.createElement("div");
    overlay.className = "video-overlay";
    // overlay.innerHTML = id;

    return overlay;
}

function moveVideoSelector(videoStack) {
    let activeVideoStack = videoStack;
    let overlay = videoStack.children[1]

    if (videoSelector.parentNode != overlay) {
        overlay.appendChild(videoSelector);
    }

    while (videoSelector.firstChild) {
        videoSelector.removeChild(videoSelector.firstChild)
    }

    for (let i = 0; i < videoStacks.length; i++) {
        let button = document.createElement("button");
        button.type = "button";
        button.className = (i != activeVideoStack.style.order
                            ? "video-selector-thumb"
                            : "video-selector-thumb-current");
        let iSwap = Number(activeVideoStack.style.order);
        button.onclick = (click) => {
            swapGridElementOrders(mainContainer, iSwap, i);
            moveVideoSelector(videoStack);
        }
        videoSelector.appendChild(button);
    }
}

// swap two css 'order' attribute values
function swapGridElementOrders(grid, order1, order2) {
    if (typeof(order1) != "number" || typeof(order2) != "number") {
        console.error("swapGridElementOrders arguments order1, order1 must be numbers");
    }
    console.debug("Swapping videoStacks: " + order1 + " with " + order2);
    if (order1 == order2) {
        return;
    }

    let videoStack1 = videoStackOrder[order1];
    let videoStack2 = videoStackOrder[order2];

    if (videoStack1 && videoStack2) {
        videoStack1.style.order = order2;
        videoStack2.style.order = order1;

        videoStackOrder[order1] = videoStack2;
        videoStackOrder[order2] = videoStack1;
    }
}

function removeAllVideoStacks() {
    while (mainContainer.firstChild) {
        mainContainer.removeChild(mainContainer.firstChild)
    }
}

function processUrlInput() {
    if (!urlInput.value) {
        return;
    }

    let videoIDs = extractVideoIDs(urlInput.value);
    videoIDs.forEach(id => {
        appendVideoStackForYoutubeID(id);
    })

    urlInput.value = "";
    updateGrid();
}

function toggleEditMode() {
    let edit = editButton.innerHTML == "Edit";
    editButton.innerHTML = edit ? "Done" : "Edit";

    if (edit && videoStacks.length > 0) {
        moveVideoSelector(videoStacks[0]);
    }

    for (let videoStack of videoStacks) {
        videoStack.children[1].style.visibility = edit ? "visible" : "hidden";
    }

    videoSelector.style.visibility = edit ? "visible" : "hidden";
    editButton.style.background = edit ? "orange" : "skyblue";
}

// Update grid to have n rows and n columns
function updateGridColAndRows() {
    let nVideoStacks = mainContainer.children.length;
    let nCols = (sizeSelect.value == "fitall" ?
                 Math.ceil(Math.sqrt(nVideoStacks)) :
                 sizeSelect.value[0]);
    // ensure enough rows to fill the entire screen
    let nRows = Math.max(Math.ceil(nVideoStacks / nCols), nCols);

    [mainContainer, videoSelector].forEach((gridElement) => {
        gridElement.style["grid-template-columns"] = "repeat(" + nCols + ", 1fr)";
        gridElement.style["grid-template-rows"] = "repeat(" + nRows + ", 1fr)";
    })

    console.debug("updateGridColAndRows: Setting dimension to " + nRows + "x" + nCols + ".");
}

// Adjust the height of the main container so that the selected number
// of rows fit on the screen.
function updateGridHeight() {
    let gridWidth = html.clientWidth;
    let screenHeight = html.clientHeight;
    let nVideoStacks = mainContainer.children.length;
    let nRowsOnScreen = (sizeSelect.value == "fitall" ?
                         Math.ceil(Math.sqrt(nVideoStacks)) :
                         sizeSelect.value[0]);
    let nTotalRows = Math.ceil(nVideoStacks / nRowsOnScreen);
    let rowHeight = Math.floor(screenHeight / nRowsOnScreen);
    let rowWidth = Math.floor(gridWidth / nRowsOnScreen);
    // Ensure the container's height fits all videos, but at least
    // enough rows (can be empty) to fill the entire screen.
    let newContainerHeight = rowHeight * Math.max(nTotalRows, nRowsOnScreen);

    mainContainer.style.height = newContainerHeight + "px";
    console.debug("New mainContainer height: " + newContainerHeight);

    // Change videoSelector width (or height) to half of the rowWidth
    // (or rowHeight) to always fit the videoSelector inside the
    // overlay.
    let dim = {width: null, height: null};
    if  (rowWidth / rowHeight < gridWidth / newContainerHeight) {
        // height for width
        dim.width = Math.floor(rowWidth / 2);
        // dim.height:dim.widht = newContainerHeight:gridWidth
        dim.height = dim.width / gridWidth * newContainerHeight;
    } else {
        // width for height
        dim.height = Math.floor(rowHeight / 2);
        // dim.height:dim.widht = newContainerHeight:gridWidth
        dim.width = dim.height / newContainerHeight * gridWidth;
    }

    videoSelector.style.width = dim.width + "px";
    videoSelector.style.height = dim.height + "px";
}

function updateGrid() {
    updateGridColAndRows();
    updateGridHeight();
}

// connect functions
urlButton.onclick = processUrlInput;
urlInput.addEventListener('keydown', (e) => {
    if (e.key == "Enter") {
        processUrlInput();
    }
})

window.onresize = (e) => {
    updateGrid();
}

window.onload = function() {
    // clear on reload
    removeAllVideoStacks();

    videoSelector = document.createElement("div");
    videoSelector.className = "video-selector";

    sizeSelect.value = "fitall";
    sizeSelect.onchange = updateGrid;

    processURL();
    updateGrid()
}

editButton.style.width = Math.max("Edit".length, "Done".length) + 1 + "em";
editButton.onclick = toggleEditMode;

  </script>

</html>


<!--

Thumbnails for videos in default resolution:

https://img.youtube.com/vi/5QbM7Vsz3kg/sddefault.jpg

-->
